---
title: "[디지털회로및실습] 2주 수업"
author: dapin1490
date: 2023-09-16 22:37:00 +09:00
categories: [IT, note]
tags: [지식, IT, 디지털 회로]
render_with_liquid: false
---

### Table of Contents
- [표본화 정리](#표본화-정리)
- [진수 변환](#진수-변환)
- [진수 연산](#진수-연산)

## 표본화 정리
* 나이퀴스트-섀넌 표본화 정리: 디지털에서 아날로그로 변환할 때 표본화 주파수가 신호의 대역의 두 배 이상이라면 표본으로부터 연속 시간 기저 대역 신호를 완전히 재구성할 수 있다.

## 진수 변환
* 8진수: 2진수를 3자리씩 묶기
* 16진수: 2진수를 4자리씩 묶기. 아라비아 숫자는 10개밖에 없으니 남은 6개는 `ABCDEF`로 표기.

<!-- -->

* 예제 2-2. 다음 8진수와 16진수를 10진수로 변환하시오.
    * (a) `475.26(8)` → `317.34375`
    * (b) `A91.CD(16)` → `2705.80078125`

<!-- -->

* 10진수-2진수 변환
    * 정수 부분은 0 또는 1만 남을 때까지 2로 나누어 나머지를 역순으로 쓰고
    * 소수 부분은 0이 될 때까지 2를 곱해 나온 값의 정수 부분을 순서대로 쓴다
    * 10진수 소수 대부분은 정확하게 2진수로 바꿀 수 없음: 소수 부분이 무한히 길어짐. 소수 부분을 소인수분해했을 때 5가 포함되지 않는다면 2를 아무리 곱해도 0이 나올 수 없음.
* 각 진법 간 변환: 적당히 과정을 잘 거쳐서 바꾸면 됨.

<!-- -->

* 예제 2-3. 10진수 `48.8125`를 2진수, 8진수, 16진수로 변환하시오.
    * 2: `110000.1101(2)`
    * 8: `60.64(8)`
    * 16: `30.D(16)`
    * 주의: 소수점 뒤에 자리가 남으면 0을 채워서 계산해야 함.

## 진수 연산
* 2진수 양수 덧셈: 10진수처럼 하면 됨
* 부호와 절대치: 최상위 비트가 음양을 표시하고 나머지 비트는 의미를 그대로 가짐. 0이 중복됨. 8비트 기준 절댓값이 128인 수를 표현할 수 없음.
* 1의 보수: 최상위 비트가 음양을 표시하는 건 같고 나머지 모든 비트를 반대로 바꿔 표현함. 0이 중복되는 건 마찬가지임. 8비트 기준 절댓값이 128인 수를 표현할 수 없음.
* 2의 보수: 1의 보수에 1을 더함. 0이 중복되지 않음. 8비트 기준 -128부터 127까지 256개 표현 가능. 음수를 양수로 바꿀 때에도 똑같이 1의 보수로 먼저 바꾸고 1을 더하면 됨.

<!-- -->

* 부호 확장: 자릿수 늘리기
    * 부호와 절대치: 부호만 MSB에 쓰고 나머지는 0으로 채움. 원래 부호 비트였던 자리는 0이 됨.
    * 1, 2의 보수: 늘어난 길이만큼 부호 비트 값으로 채움. 원래 부호 비트였던 자리는 그대로 유지.

<!-- -->

* 2의 보수 음수를 10진수로 변환
    1. MSB만 음수로 취급하여 모든 자릿값을 그대로 계산한 후 합산
    2. 2의 보수로 바꿔 계산 후 부호 붙이기

<!-- -->

* 2진수 정수 연산(2의 보수)
    * 결과가 표현 범위 이내인 값의 연산은 가능
    * 절댓값이 크고 부호가 같은 수의 덧셈은 overflow 문제로 연산 불가
    * 마지막에 나오는 두 carry의 값이 서로 다르면 overflow 발생. 오류 값은 원래 나와야 하는 값과 `2^(비트 수)` 만큼 차이난다.
* 정수 연산에 2의 보수를 쓰는 이유: 비트 연산을 그대로 해도 올바른 값이 나옴. 다른 보수법은 결과가 실제와 다르게 나옴.