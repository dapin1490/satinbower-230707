---
title: "[UROP] 3주 - 1. 복습, 데이터 결측치와 원 핫 인코딩"
author: dapin1490
date: 2022-06-06 00:00:00 +09:00
categories: [IT, Machine Learning]
tags: [프로젝트, 지식, IT, 결측치, 원핫인코딩]
render_with_liquid: false
---

<style>
	.more-study { color: #915ee7 }
    .comment { color: #828282 }
</style>

&#42; <span class="x-understand">노란 글씨</span> : 이해 잘 안 됨  
&#42; <span class="understand">파란 글씨</span> : 이해 후 재서술  

<br>

## 1, 2주 복습
- DNN은 대부분 딥러닝 모델의 밑바탕이 되는 기본적인 구조이다.
- CNN은 컨볼루션과 풀링이 사용되는 신경망이고, 정보 추출, 문장 분류, 이미지 처리에 잘 쓰인다.
- 활성화 함수는 직선밖에 모르는 DNN이 제대로 기능할 수 있도록 직선이 아닌 것을 직선처럼 보이게 만들어 준다.
- 편향은 모델이 예측하는 값이 정답으로부터 얼마나 떨어져있는지 나타낸다. 분산은 모델이 예측하는 값이 얼마나 퍼져있는지 나타낸다. 예측과 정답이 가까울수록 편향이 낮고, 예측이 일정할수록 분산이 낮다.
- 편향과 분산은 '모델이 복잡한 정도'와 관련이 있다. 모델을 적절히 학습시켜 학습 데이터에 지나치게 딱 맞게 되지 않도록 하는 게 좋다.
- Regularization(정규화, 규제) : 모델이 가질 수 있는 분산에 제약을 부여한다. 과하면 편향이 증가할 수 있으니 적당히 해야 한다. 과적합을 줄일 수 있다.
- 내가 사용하는 모델은 대부분 mini-batch 방식.
- 배치 정규화는 모델의 가중치가 특정 방향으로 몰리지 않도록 하기 위한 가중치 바로세우기.
- optimizer는 모델이 지역최솟값에 빠지지 않게 도와준다지만 어떻게 적당한 optimizer를 고르는지는 모르겠다.
- hyperparameter : 내가 모델에게 정해주는 파라미터 값. 학습이 불가능하며 경험적으로 적당한 값을 찾아야 한다.

<br>

- CNN은 이미지를 처리할 때 이미지의 공간적 정보를 유지하면서 학습할 수 있다. 그것이 DNN과의 차이.
- 활성화 함수는 다음 층으로 넘길 신호의 세기를 정한다. 중요한 값은 세게, 그렇지 않은 값은 약하게.

<br>

- 선형 회귀 : 어떤 변수의 값을 기반으로 다른 변수의 값을 예측한다. 선형 방정식을 이용하며 지도학습이다. 단순 선형 회귀, 다중 선형 회귀, 로지스틱 회귀, Cox 비례 회귀 등이 있다.

<br>

- 산점도를 그리면 변수들 사이의 상관 관계를 눈으로 확인할 수 있다.
- `tf.newaxis` : 필요한 곳에 한 차원 추가
- 나는 아직 내가 많은 요소를 직접 만들고 지정해야 하는 모델을 다루기는 힘들다. 코드를 이해하려 하는 건 좋지만 그걸 써먹을 수 없겠다는 생각이 들면 곤란하다. 앞으로는 쓸 수 있는 코드를 보자.
- 콜백을 직접 만들어 본 건 괜찮은 경험이었다. 그래도 API 쓰는 게 훨씬 성능이 좋다.
- custom metric을 만들 수 있다. r2 score를 metric으로 사용하고 싶었다.
- 선형 회귀는 주기함수 형태를 띄는 데이터에는 잘 적응하지 못한다고 한다. 나중에 실험해볼 여지가 있다.

<br>

## 데이터 결측치 처리 방법
1. 삭제하기
2. 대충 채우기
  
<br>

### 삭제하기
결측치가 많지 않고, 전체적인 경향을 훼손하지 않을 만하다면 결측치가 포함된 행이나 열을 삭제하는 게 낫다. 특정 샘플에 결측치가 많으면 행을 삭제하고 특정 속성에 결측치가 많으면 열을 삭제한다.  
- 행 삭제, 열 삭제
- 모든 속성이 결측치인 샘플만 삭제
- 결측치가 n개 이상인 샘플만 삭제(thresh)
- 특정 열에 결측치가 있는 샘플만 삭제(다른 열에는 결측치 있든 말든)
  
<br>

### 채우기
평균, 중앙값 등의 통계치로 채울 수 있고, 결측치에 경향이 있을 경우(결측치가 랜덤으로 빠진 게 아닐 경우), 결측치를 채우기 위해 학습할 수 있다. 기계학습, 데이터 마이닝 등 다양한 방법이 있다고 함. 범주형 변수와 그렇지 않은 것을 구분하여 채워야 한다.  
- 단일 값으로 지정하여 채우기
- 결측치 전후 값으로 채우기
- 특정 값으로 대체하기(replace) : 결측치가 아닌 경우에도 사용 가능
- `interpolate` : 결측치를 선형으로 채움. 데이터와 데이터 사이의 빈 공간에 직선을 긋는다고 생각하면 됨. 다차원 함수 형태로도 가능하다고 함.

<br>

- k-최근접 이웃 알고리즘 이용한 사이킷런의 KNN Imputer로 채우기. 다양한 Imputer가 있다고 한다.

참고 : [6.4. Imputation of missing values](https://scikit-learn.org/stable/modules/impute.html), [Imputing missing values before building an estimator](https://scikit-learn.org/stable/auto_examples/impute/plot_missing_values.html), [sklearn.impute.SimpleImputer](https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html), [[파이썬] 머신러닝 결측치/결측값 처리 : 싸이킷런 KNN Imputer로 KNN 알고리즘으로 결측값 채우기/대체/보간하기](https://blog.naver.com/youji4ever/222013171055)  

<br>

## 결측치 유형
* 값에 따른 분류
    - None/null : 진짜로 값이 없음. → 모든 자료형
    - NaN : 뭔가 있긴 있는데 해당 시스템이 지원하는 타입의 숫자가 아님. → int, float 자료형
    - NA : 유효하지 않음. → object 자료형

<br>

* 결측 유형에 따른 분류
    - 완전 무작위 결측 : 결측치가 결측치인 이유가 없음. 입력할 때 실수했거나 오류가 났을 뿐임.
    - 무작위 결측 : 다른 속성의 값에 따라 결측치가 정해질 수 있음(maybe) == 다른 속성의 값에 따라 결측치 발생 확률이 계산되긴 하는데, 값 자체의 상관관계는 알 수 없음.
    - 비무작위 결측 : 어떠한 무작위 결측도 아님. 결측치가 발생한 값이 다른 값과 연관이 있음(certainly).

<br>

## 원 핫 인코딩
*<span class="comment">이건.. 그냥 [내가 전에 썼던 블로그 글](https://dapin1490.github.io/satinbower/posts/it-deeplearning-data-1/) 그대로 가져오겠다. 이것까지 새로 찾아볼 기운이 안 나거든요.(사유 : 컨디션 문제)</span>*  
&#42; 아래 글은 클래스의 원 핫 인코딩에 대해서만 설명하고 있는데, 클래스가 아니라 속성에 원 핫 인코딩을 할 수도 있다. 이 또한 범주형 값일 때 가능하며 `pandas.get_dummies()`를 사용할 수 있다.  

<br>
  
- **원 핫 인코딩, 원 핫 벡터 : 다른 건 보지 마 이게 정답이야 이것만 봐 좀**  
    원 핫 인코딩은 예측해야 할 클래스가 선형 회귀가 아니고, 여러 개일 때 사용할 수 있는 방법이다. 예를 들어 0번부터 3번까지 클래스가 3개 있다고 하자. 프로그래머는 딥러닝 모델에게 이 클래스를 그대로 [0, 1, 2, 3]라고 전달할 수 있다. 그러나 보통은 원 핫 인코딩을 거쳐 [ [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1] ] 이런 형태로 전달한다. 이렇게 정답 클래스의 인덱스만 1로 표시하고 나머지는 0으로 표시하는 것이 원 핫 인코딩이다. 그리고 원 핫 인코딩을 한 클래스 각각을 원 핫 벡터라고 한다.

<br>

- **원 핫 벡터의 길이 : 누가 여기서 가장 크냐?**  
    방금 예시에서는 클래스가 0부터 3까지 있었다. 그럼 만약 클래스가 1과 3만 있는 데이터를 원 핫 인코딩 한다면 어떻게 될까? 사람 기준에서는 어차피 둘 중 하나이니 [ [1, 0], [0, 1] ] 이렇게만 만들면 될 것 같지만 실제로 원 핫 인코딩을 해보면 위의 예시와 똑같은 결과가 나온다. 이유는 원 핫 인코딩이 표시하는 것이 클래스의 상대적 순서가 아니라, 인덱스 자체이기 때문이다. 파이썬의 인덱스는 0부터 시작하니, 정수로 표시된 클래스들 중 가장 큰 수를 받은 클래스의 숫자 + 1이 원 핫 벡터의 길이가 되고, 동시에 그것이 출력층의 노드 개수가 된다(클래스의 인덱스를 음수로 주는 경우는 본 적이 없다). 이는 자연어 처리에서도 똑같이 적용된다만, 지금 정리할 개념은 아니니 언급만 해둔다.

<br>

- **원 핫 인코딩 왜 함?**  
    원 핫 벡터에 사용되는 숫자와 클래스에 매겨지는 인덱스에 사용되는 숫자를 생각해 보자. 클래스 인덱스는 10진수로 매겨진다. 원 핫 벡터는 0과 1만 사용하니 2진수라고 할 수 있겠다. 10진수와 2진수의 차이가 뭘까? 10진수는 산수가 되고 2진수는 안 된다는 점이다. 10진수인 1과 2를 더하면 3이 되지만 원 핫 벡터는 모든 값을 0과 1로만 표시하면서 그런 계산을 불가능하게 만들었다. 이 부분이 원 핫 인코딩의 장점이자 단점이다.  
      
    사람은 데이터의 의미를 이해할 수 있으니 1번 클래스와 2번 클래스를 더하는 것과 3번 클래스는 무관하다는 사실을 인지할 수 있다. 하지만 모델은 그런 생각을 할 수 없다. 그렇기 때문에 클래스의 인덱스를 10진수로 주면 1 + 2 = 3이니까 1번 클래스와 2번 클래스를 더하면 3번 클래스와 같을 거라는 잘못된 학습을 할 수도 있다. 원 핫 인코딩은 이 문제를 방지한다. 이것이 장점이다.  
      
    반면 실제로 1번 클래스와 2번 클래스의 합이 3번 클래스와 관계가 있는 데이터도 있을 수 있다. 예를 들면 자연어 처리가 그러하다. 하나의 문장 내에서 각각의 단어는 무관하지 않다. "오늘 날씨"와 "내일 날씨"는 같은 "날씨"를 요구한다고 해도 다르게 해석되어야 한다. 원 핫 인코딩은 이런 관계성을 차단하여 클래스 사이의 유사성도 나타내지 못하게 된다는 것이 단점이다.

<br>

## 참고 자료
1. [[데이터분석] 결측치/결측값(missing value) 처리를 위한 2가지 방법](https://blog.naver.com/youji4ever/221690373437)
2. [[파이썬] 판다스(pandas) 팁14. 결측치/결측값 처리 : 제거하기/삭제하기(Deletion)](https://blog.naver.com/youji4ever/221712578078)
3. [[파이썬] 판다스(pandas) 팁19. 결측치/결측값 처리 : 채우기/보간하기/대체하기(Imputation)](https://blog.naver.com/youji4ever/221791455668)
4. [[데이터시각화] 파이썬 : 결측치/결측값(missing value) 시각화하는 5가지 방법](https://blog.naver.com/youji4ever/221623491491)
5. [결측치(Missing Value) 처리](https://junklee.tistory.com/4)